<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>‚ùÑÔ∏è Snowball Run</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(to bottom, #bfdbfe, #ffffff);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: hidden;
        }
        
        #game-container {
            text-align: center;
        }
        
        .menu-screen, .gameover-screen {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 400px;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            color: #2563eb;
            font-size: 2.5em;
            margin-bottom: 16px;
        }
        
        h2 {
            color: #dc2626;
            font-size: 2em;
            margin-bottom: 16px;
        }
        
        p {
            color: #374151;
            margin-bottom: 16px;
            line-height: 1.6;
        }
        
        .instructions {
            background: #eff6ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: left;
        }
        
        .instructions h3 {
            font-weight: bold;
            margin-bottom: 12px;
        }
        
        .instructions ul {
            list-style: none;
            font-size: 0.9em;
        }
        
        .instructions li {
            margin: 8px 0;
        }
        
        button {
            background: #3b82f6;
            color: white;
            font-weight: bold;
            padding: 16px 32px;
            border: none;
            border-radius: 50px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background 0.3s;
            margin: 8px;
        }
        
        button:hover {
            background: #2563eb;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        button.secondary {
            background: #10b981;
        }
        
        button.secondary:hover {
            background: #059669;
        }
        
        canvas {
            border: 4px solid #93c5fd;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            touch-action: none;
            display: block;
            margin: 0 auto;
        }
        
        .game-hud {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            margin-bottom: 12px;
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }
        
        .hud-label {
            font-size: 0.75em;
            opacity: 0.8;
            margin-bottom: 2px;
        }
        
        .hud-value {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .touch-slider {
            width: 100%;
            max-width: 400px;
            height: 60px;
            position: relative;
            margin-top: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }
        
        .slider-track {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
            transform: translateY(-50%);
        }
        
        .slider-handle {
            position: absolute;
            top: 50%;
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease-out;
            left: 50%;
        }
        
        .slider-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .score-display {
            margin: 20px 0;
        }
        
        .score-display p {
            font-size: 1.3em;
            margin: 8px 0;
        }
        
        .score-display span {
            font-weight: bold;
            color: #2563eb;
        }
        
        .high-score {
            color: #16a34a;
            font-weight: bold;
            font-size: 1.1em;
            margin: 12px 0;
        }
        
        .new-record {
            color: #16a34a;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .last-run {
            background: #f3f4f6;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .last-run h3 {
            font-size: 1em;
            color: #6b7280;
            margin-bottom: 8px;
        }
        
        .last-run p {
            font-size: 1.1em;
            margin: 4px 0;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }
        
        .modal {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal-header {
            padding: 24px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
            color: #2563eb;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .modal-close:hover {
            background: #f3f4f6;
        }
        
        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }
        
        .modal-footer {
            padding: 24px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .modal-footer button {
            padding: 12px 24px;
            font-size: 1em;
            margin: 0;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #374151;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.2s;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .stats-box {
            background: #f3f4f6;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .stats-box p {
            margin: 8px 0;
            font-size: 1.1em;
        }
        
        .rank-badge {
            display: inline-block;
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .rank-badge.gold {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }
        
        .rank-badge.silver {
            background: linear-gradient(135deg, #d1d5db, #9ca3af);
        }
        
        .rank-badge.bronze {
            background: linear-gradient(135deg, #d97706, #b45309);
        }
        
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaderboard-table th {
            background: #f3f4f6;
            padding: 12px 8px;
            text-align: left;
            font-weight: bold;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .leaderboard-table td {
            padding: 12px 8px;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .leaderboard-table tr:hover {
            background: #f9fafb;
        }
        
        .leaderboard-table .rank-col {
            width: 50px;
            text-align: center;
            font-weight: bold;
            color: #6b7280;
        }
        
        .leaderboard-table .name-col {
            font-weight: 500;
            color: #374151;
        }
        
        .leaderboard-table .distance-col,
        .leaderboard-table .collisions-col {
            text-align: right;
            color: #6b7280;
        }
        
        .leaderboard-table .highlight {
            background: #dbeafe;
            font-weight: bold;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .empty-state p {
            font-size: 1.1em;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu-screen" class="menu-screen">
            <h1>‚ùÑÔ∏è Snowball Run</h1>
            <p>Roll down the endless hill! Avoid obstacles to keep your snowball intact.</p>
            <div class="instructions">
                <h3>How to Play:</h3>
                <ul>
                    <li>‚Ä¢ Swipe or drag to move the snowball</li>
                    <li>‚Ä¢ Start at size 3, grow to max size 20</li>
                    <li>‚Ä¢ Each collision reduces size by 1</li>
                    <li>‚Ä¢ Game over when size reaches 0</li>
                    <li>‚Ä¢ Survive as long as possible!</li>
                </ul>
            </div>
            <div id="last-run-stats" class="last-run hidden">
                <h3>Last Run:</h3>
                <p>Distance: <span id="last-distance">0</span></p>
                <p>Collisions: <span id="last-collisions">0</span></p>
            </div>
            <p id="high-score-display" class="high-score hidden"></p>
            <button onclick="startGame()">Start New Run</button>
            <button onclick="openLeaderboard()" class="secondary">üèÜ Online Leaderboard</button>
        </div>
        
        <div id="game-hud" class="game-hud hidden">
            <div class="hud-item">
                <span class="hud-label">Distance:</span>
                <span class="hud-value" id="hud-distance">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Size:</span>
                <span class="hud-value" id="hud-size">3.0/20</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Collisions:</span>
                <span class="hud-value" id="hud-collisions">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Speed:</span>
                <span class="hud-value" id="hud-speed">8.4</span>
            </div>
        </div>
        
        <canvas id="game-canvas" class="hidden"></canvas>
        
        <div id="touch-slider" class="touch-slider hidden">
            <div class="slider-track"></div>
            <div class="slider-handle" id="slider-handle"></div>
        </div>
        
        <div id="gameover-screen" class="gameover-screen hidden">
            <h2>Game Over!</h2>
            <div class="score-display">
                <p>Distance: <span id="final-score">0</span></p>
                <p>Collisions: <span id="final-collisions">0</span></p>
                <p id="new-record" class="new-record hidden">üèÜ New High Score!</p>
                <p id="current-high-score" class="hidden"></p>
            </div>
            <button onclick="startGame()">Start New Run</button>
            <button onclick="openLogRunModal()" class="secondary">üìù Log Run to Leaderboard</button>
        </div>
    </div>

    <!-- Log Run Modal -->
    <div id="log-run-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h2>üìù Log Your Run</h2>
                <button class="modal-close" onclick="closeLogRunModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="stats-box">
                    <p><strong>Distance:</strong> <span id="log-distance">0</span></p>
                    <p><strong>Collisions:</strong> <span id="log-collisions">0</span></p>
                    <p><strong>Max Size:</strong> <span id="log-maxsize">0</span></p>
                    <p id="log-rank"></p>
                </div>
                <div class="form-group">
                    <label for="player-name">Your Name (optional)</label>
                    <input type="text" id="player-name" placeholder="Anonymous" maxlength="30">
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="closeLogRunModal()" style="background: #6b7280;">Cancel</button>
                <button onclick="saveRunToLeaderboard()">Save to Leaderboard</button>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h2>üèÜ Online Leaderboard</h2>
                <button class="modal-close" onclick="closeLeaderboard()">√ó</button>
            </div>
            <div class="modal-body" id="leaderboard-body">
                <div class="loading">Loading leaderboard...</div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB0qBapWj3VBCIkVm8jcNvDkT4jgZuBvSI",
            authDomain: "snowball-run-4767d.firebaseapp.com",
            projectId: "snowball-run-4767d",
            storageBucket: "snowball-run-4767d.firebasestorage.app",
            messagingSenderId: "409188975425",
            appId: "1:409188975425:web:eb9950b0be43ae3e95d7c0",
            measurementId: "G-5REM2H2QTM",
            databaseURL: "https://snowball-run-4767d-default-rtdb.firebaseio.com"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // Current run ID for updating after game over
        let currentRunId = null;
        let currentMaxSize = 3;
        let runHasBeenLogged = false;
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'menu';
        let score = 0;
        let collisions = 0;
        let highScore = localStorage.getItem('snowballHighScore') || 0;
        let lastRunDistance = 0;
        let lastRunCollisions = 0;
        
        // Separate touch position tracking (doesn't affect game speed at all)
        let currentTouchX = null;
        let touchOffsetX = 0;
        
        // Snow trail particles
        let snowTrail = [];
        
        let game = {
            snowball: { x: 150, y: 100, size: 3, maxSize: 20 },
            obstacles: [],
            baseScrollSpeed: 8.4,
            scrollSpeed: 8.4,
            obstacleSpawnTimer: 0,
            distance: 0,
            animationId: null,
            lastFrameTime: 0
        };
        
        function resizeCanvas() {
            canvas.width = Math.min(window.innerWidth - 40, 400);
            canvas.height = Math.min(window.innerHeight - 140, 600);
            game.snowball.x = canvas.width / 2;
        }
        
        function showScreen(screen) {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-canvas').classList.add('hidden');
            document.getElementById('game-hud').classList.add('hidden');
            document.getElementById('touch-slider').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');
            
            if (screen === 'menu') {
                document.getElementById('menu-screen').classList.remove('hidden');
                if (highScore > 0) {
                    document.getElementById('high-score-display').classList.remove('hidden');
                    document.getElementById('high-score-display').textContent = `High Score: ${highScore}`;
                }
                
                if (lastRunDistance > 0) {
                    document.getElementById('last-run-stats').classList.remove('hidden');
                    document.getElementById('last-distance').textContent = lastRunDistance;
                    document.getElementById('last-collisions').textContent = lastRunCollisions;
                }
            } else if (screen === 'playing') {
                document.getElementById('game-hud').classList.remove('hidden');
                document.getElementById('game-canvas').classList.remove('hidden');
                document.getElementById('touch-slider').classList.remove('hidden');
            } else if (screen === 'gameover') {
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score').textContent = score;
                document.getElementById('final-collisions').textContent = collisions;
                
                // Show or hide log button based on whether run has been logged
                const logButton = document.querySelector('#gameover-screen button.secondary');
                if (runHasBeenLogged) {
                    logButton.style.display = 'none';
                } else {
                    logButton.style.display = 'inline-block';
                }
                
                if (score >= highScore && score > 0) {
                    document.getElementById('new-record').classList.remove('hidden');
                    document.getElementById('current-high-score').classList.add('hidden');
                } else if (highScore > 0) {
                    document.getElementById('new-record').classList.add('hidden');
                    document.getElementById('current-high-score').classList.remove('hidden');
                    document.getElementById('current-high-score').textContent = `High Score: ${highScore}`;
                }
            }
        }
        
        function updateSliderPosition() {
            const sliderHandle = document.getElementById('slider-handle');
            const percentage = (game.snowball.x / canvas.width) * 100;
            sliderHandle.style.left = `${percentage}%`;
        }
        
        function updateHUD() {
            document.getElementById('hud-distance').textContent = score;
            document.getElementById('hud-size').textContent = `${game.snowball.size.toFixed(1)}/${game.snowball.maxSize}`;
            document.getElementById('hud-collisions').textContent = collisions;
            document.getElementById('hud-speed').textContent = game.scrollSpeed.toFixed(1);
        }
        
        // Allow touch anywhere on screen (not just canvas)
        document.addEventListener('touchstart', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            
            const touchX = e.touches[0].clientX;
            const rect = canvas.getBoundingClientRect();
            const canvasX = touchX - rect.left;
            
            touchOffsetX = game.snowball.x - canvasX;
            currentTouchX = canvasX;
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            
            if (currentTouchX === null) return;
            
            const touchX = e.touches[0].clientX;
            const rect = canvas.getBoundingClientRect();
            const canvasX = touchX - rect.left;
            
            game.snowball.x = canvasX + touchOffsetX;
            
            const radius = game.snowball.size * 5;
            game.snowball.x = Math.max(radius, Math.min(canvas.width - radius, game.snowball.x));
            
            currentTouchX = canvasX;
            updateSliderPosition();
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            currentTouchX = null;
        }, { passive: false });
        
        document.addEventListener('touchcancel', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            currentTouchX = null;
        }, { passive: false });
        
        async function saveRunToFirebase(distance, collisions, maxSize, name = "Anonymous") {
            try {
                const runData = {
                    name: name,
                    distance: distance,
                    collisions: collisions,
                    maxSize: maxSize,
                    timestamp: Date.now()
                };
                
                // If updating with a real name (not Anonymous), check if this name already exists
                if (name !== "Anonymous") {
                    const snapshot = await database.ref('runs').orderByChild('name').equalTo(name).once('value');
                    
                    if (snapshot.exists()) {
                        // Name exists - find the best run to update
                        let bestRunId = null;
                        let bestDistance = -1;
                        
                        snapshot.forEach((childSnapshot) => {
                            const run = childSnapshot.val();
                            if (run.distance > bestDistance) {
                                bestDistance = run.distance;
                                bestRunId = childSnapshot.key;
                            }
                        });
                        
                        // Only update if this new run is better, otherwise delete other entries
                        if (distance >= bestDistance) {
                            // Delete all other runs with this name
                            const deletions = [];
                            snapshot.forEach((childSnapshot) => {
                                if (childSnapshot.key !== currentRunId) {
                                    deletions.push(database.ref('runs/' + childSnapshot.key).remove());
                                }
                            });
                            await Promise.all(deletions);
                            
                            // Update current run
                            await database.ref('runs/' + currentRunId).update(runData);
                            return currentRunId;
                        } else {
                            // New run is worse - delete current run and keep the best
                            await database.ref('runs/' + currentRunId).remove();
                            return bestRunId;
                        }
                    }
                }
                
                if (currentRunId) {
                    // Update existing run
                    await database.ref('runs/' + currentRunId).update(runData);
                    return currentRunId;
                } else {
                    // Create new run
                    const newRunRef = await database.ref('runs').push(runData);
                    return newRunRef.key;
                }
            } catch (error) {
                console.error("Error saving run:", error);
                return null;
            }
        }
        
        async function getRankForDistance(distance) {
            try {
                const snapshot = await database.ref('runs').orderByChild('distance').once('value');
                const runs = [];
                snapshot.forEach((childSnapshot) => {
                    runs.push(childSnapshot.val());
                });
                
                // Sort by distance descending
                runs.sort((a, b) => b.distance - a.distance);
                
                // Find rank
                const rank = runs.findIndex(run => run.distance <= distance) + 1;
                return rank || runs.length + 1;
            } catch (error) {
                console.error("Error getting rank:", error);
                return null;
            }
        }
        
        function openLogRunModal() {
            // Prevent opening if already logged
            if (runHasBeenLogged) {
                return;
            }
            
            document.getElementById('log-distance').textContent = score;
            document.getElementById('log-collisions').textContent = collisions;
            document.getElementById('log-maxsize').textContent = currentMaxSize.toFixed(1);
            
            // Load saved name if exists
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                document.getElementById('player-name').value = savedName;
            }
            
            // Get and display rank
            getRankForDistance(score).then(rank => {
                if (rank !== null) {
                    let rankBadgeClass = '';
                    if (rank === 1) rankBadgeClass = 'gold';
                    else if (rank === 2) rankBadgeClass = 'silver';
                    else if (rank === 3) rankBadgeClass = 'bronze';
                    
                    document.getElementById('log-rank').innerHTML = 
                        `<strong>Current Rank:</strong> <span class="rank-badge ${rankBadgeClass}">#${rank}</span>`;
                }
            });
            
            document.getElementById('log-run-modal').classList.remove('hidden');
        }
        
        function closeLogRunModal() {
            document.getElementById('log-run-modal').classList.add('hidden');
        }
        
        async function saveRunToLeaderboard() {
            const playerName = document.getElementById('player-name').value.trim() || "Anonymous";
            
            // Save name to localStorage for next time
            if (playerName !== "Anonymous") {
                localStorage.setItem('playerName', playerName);
            }
            
            // Update the run in Firebase
            await saveRunToFirebase(score, collisions, currentMaxSize, playerName);
            
            // Mark run as logged
            runHasBeenLogged = true;
            
            closeLogRunModal();
            
            // Update the game over screen to hide the log button
            const logButton = document.querySelector('#gameover-screen button.secondary');
            if (logButton) {
                logButton.style.display = 'none';
            }
            
            // Show success message or open leaderboard
            openLeaderboard();
        }
        
        async function openLeaderboard() {
            document.getElementById('leaderboard-modal').classList.remove('hidden');
            document.getElementById('leaderboard-body').innerHTML = '<div class="loading">Loading leaderboard...</div>';
            
            try {
                const snapshot = await database.ref('runs').orderByChild('distance').limitToLast(20).once('value');
                const runs = [];
                
                snapshot.forEach((childSnapshot) => {
                    runs.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                
                // Sort by distance descending (since limitToLast gives us ascending)
                runs.sort((a, b) => b.distance - a.distance);
                
                if (runs.length === 0) {
                    document.getElementById('leaderboard-body').innerHTML = `
                        <div class="empty-state">
                            <p>No runs yet!</p>
                            <p style="font-size: 0.9em;">Be the first to set a record!</p>
                        </div>
                    `;
                    return;
                }
                
                let tableHTML = `
                    <table class="leaderboard-table">
                        <thead>
                            <tr>
                                <th class="rank-col">Rank</th>
                                <th class="name-col">Name</th>
                                <th class="distance-col">Distance</th>
                                <th class="collisions-col">Hits</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                runs.forEach((run, index) => {
                    const rank = index + 1;
                    let rankDisplay = `#${rank}`;
                    
                    if (rank === 1) rankDisplay = 'ü•á';
                    else if (rank === 2) rankDisplay = 'ü•à';
                    else if (rank === 3) rankDisplay = 'ü•â';
                    
                    const isCurrentRun = run.id === currentRunId;
                    const highlightClass = isCurrentRun ? 'highlight' : '';
                    
                    tableHTML += `
                        <tr class="${highlightClass}">
                            <td class="rank-col">${rankDisplay}</td>
                            <td class="name-col">${run.name}</td>
                            <td class="distance-col">${run.distance}</td>
                            <td class="collisions-col">${run.collisions}</td>
                        </tr>
                    `;
                });
                
                tableHTML += `
                        </tbody>
                    </table>
                `;
                
                // If current run is not in top 20, show their rank
                if (currentRunId) {
                    const currentRunInTop20 = runs.some(run => run.id === currentRunId);
                    if (!currentRunInTop20) {
                        const allSnapshot = await database.ref('runs').orderByChild('distance').once('value');
                        const allRuns = [];
                        allSnapshot.forEach((childSnapshot) => {
                            allRuns.push({
                                id: childSnapshot.key,
                                ...childSnapshot.val()
                            });
                        });
                        allRuns.sort((a, b) => b.distance - a.distance);
                        const rank = allRuns.findIndex(run => run.id === currentRunId) + 1;
                        
                        if (rank > 0) {
                            tableHTML += `
                                <div style="margin-top: 20px; padding: 16px; background: #dbeafe; border-radius: 8px; text-align: center;">
                                    <strong>Your Rank: #${rank}</strong>
                                </div>
                            `;
                        }
                    }
                }
                
                document.getElementById('leaderboard-body').innerHTML = tableHTML;
                
            } catch (error) {
                console.error("Error loading leaderboard:", error);
                document.getElementById('leaderboard-body').innerHTML = `
                    <div class="empty-state">
                        <p>Error loading leaderboard</p>
                        <p style="font-size: 0.9em;">Please try again later</p>
                    </div>
                `;
            }
        }
        
        function closeLeaderboard() {
            document.getElementById('leaderboard-modal').classList.add('hidden');
        }
        
        function startGame() {
            resizeCanvas();
            
            game = {
                snowball: { x: canvas.width / 2, y: 100, size: 3, maxSize: 20 },
                obstacles: [],
                baseScrollSpeed: 8.4,
                scrollSpeed: 8.4,
                obstacleSpawnTimer: 0,
                distance: 0,
                animationId: null,
                lastFrameTime: performance.now()
            };
            
            currentTouchX = null;
            touchOffsetX = 0;
            snowTrail = [];
            currentMaxSize = 3;
            currentRunId = null;
            runHasBeenLogged = false;
            
            score = 0;
            collisions = 0;
            gameState = 'playing';
            showScreen('playing');
            
            gameLoop(performance.now());
        }
        
        // Touch event handlers - ONLY update position, never affect game state
        function handleTouchStart(e) {
            if (gameState !== 'playing') return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            
            // Calculate offset from current snowball position
            touchOffsetX = game.snowball.x - touchX;
            currentTouchX = touchX;
        }
        
        function handleTouchMove(e) {
            if (gameState !== 'playing') return;
            e.preventDefault();
            
            if (currentTouchX === null) return;
            
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            
            // Update snowball position with offset
            game.snowball.x = touchX + touchOffsetX;
            
            // Keep in bounds
            const radius = game.snowball.size * 5;
            game.snowball.x = Math.max(radius, Math.min(canvas.width - radius, game.snowball.x));
            
            currentTouchX = touchX;
            
            // Update slider handle position
            updateSliderPosition();
        }
        
        function handleTouchEnd(e) {
            if (gameState !== 'playing') return;
            e.preventDefault();
            currentTouchX = null;
        }
        
        // Add event listeners
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        
        // Mouse controls
        let mouseDown = false;
        let mouseOffsetX = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'playing') return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            
            mouseOffsetX = game.snowball.x - mouseX;
            mouseDown = true;
        });
        
        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!mouseDown || gameState !== 'playing') return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            
            game.snowball.x = mouseX + mouseOffsetX;
            
            const radius = game.snowball.size * 5;
            game.snowball.x = Math.max(radius, Math.min(canvas.width - radius, game.snowball.x));
            
            updateSliderPosition();
        });
        
        function spawnObstacle() {
            const types = ['rock', 'tree', 'log'];
            const type = types[Math.floor(Math.random() * types.length)];
            const size = 15 + Math.random() * 20;
            
            game.obstacles.push({
                x: Math.random() * (canvas.width - size * 2) + size,
                y: canvas.height + 50,
                size,
                type
            });
        }
        
        function checkCollision(snowball, obstacle) {
            const snowballRadius = snowball.size * 5;
            const dx = snowball.x - obstacle.x;
            const dy = snowball.y - obstacle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return distance < snowballRadius + obstacle.size;
        }
        
        function drawSnowball(x, y, size) {
            const radius = size * 5;
            
            // Create gradient for 3D effect
            const gradient = ctx.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, '#FFFFFF');
            gradient.addColorStop(0.5, '#F5F5F5');
            gradient.addColorStop(1, '#E0E0E0');
            
            // Draw main snowball with gradient
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add subtle shadow/outline
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Add highlight for shine
            const highlight = ctx.createRadialGradient(
                x - radius * 0.4, y - radius * 0.4, 0,
                x - radius * 0.4, y - radius * 0.4, radius * 0.4
            );
            highlight.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = highlight;
            ctx.beginPath();
            ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Add texture with small snow clumps
            ctx.fillStyle = 'rgba(240, 240, 240, 0.6)';
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8 + game.distance * 0.01;
                const distance = radius * 0.5 + (Math.sin(angle * 3) * radius * 0.2);
                const dotX = x + Math.cos(angle) * distance;
                const dotY = y + Math.sin(angle) * distance;
                const dotSize = 1 + Math.random() * 2;
                ctx.beginPath();
                ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawObstacle(obstacle) {
            if (obstacle.type === 'rock') {
                // Draw shadow first
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(obstacle.x + 2, obstacle.y + obstacle.size + 2, obstacle.size * 0.8, obstacle.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Rock gradient
                const rockGradient = ctx.createRadialGradient(
                    obstacle.x - obstacle.size * 0.3, obstacle.y - obstacle.size * 0.3, obstacle.size * 0.1,
                    obstacle.x, obstacle.y, obstacle.size
                );
                rockGradient.addColorStop(0, '#A89080');
                rockGradient.addColorStop(0.5, '#8B7355');
                rockGradient.addColorStop(1, '#6B5845');
                
                ctx.fillStyle = rockGradient;
                ctx.strokeStyle = '#5C4A3A';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Add some texture spots
                ctx.fillStyle = 'rgba(90, 70, 50, 0.4)';
                for (let i = 0; i < 3; i++) {
                    const angle = (i * Math.PI * 2) / 3;
                    const spotX = obstacle.x + Math.cos(angle) * obstacle.size * 0.5;
                    const spotY = obstacle.y + Math.sin(angle) * obstacle.size * 0.5;
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, obstacle.size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (obstacle.type === 'tree') {
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(obstacle.x, obstacle.y + 15, obstacle.size * 0.6, obstacle.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Trunk with gradient
                const trunkGradient = ctx.createLinearGradient(obstacle.x - 5, 0, obstacle.x + 5, 0);
                trunkGradient.addColorStop(0, '#4A3621');
                trunkGradient.addColorStop(0.5, '#654321');
                trunkGradient.addColorStop(1, '#4A3621');
                ctx.fillStyle = trunkGradient;
                ctx.fillRect(obstacle.x - 5, obstacle.y - 10, 10, 20);
                
                // Trunk outline
                ctx.strokeStyle = '#3A2611';
                ctx.lineWidth = 1;
                ctx.strokeRect(obstacle.x - 5, obstacle.y - 10, 10, 20);
                
                // Foliage with gradient
                const foliageGradient = ctx.createRadialGradient(
                    obstacle.x - obstacle.size * 0.2, obstacle.y - obstacle.size - obstacle.size * 0.2, obstacle.size * 0.1,
                    obstacle.x, obstacle.y - obstacle.size, obstacle.size
                );
                foliageGradient.addColorStop(0, '#3FA34D');
                foliageGradient.addColorStop(0.5, '#228B22');
                foliageGradient.addColorStop(1, '#1B6B1B');
                
                ctx.fillStyle = foliageGradient;
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y - obstacle.size, obstacle.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add some darker spots for depth
                ctx.fillStyle = 'rgba(27, 107, 27, 0.5)';
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
                    const spotX = obstacle.x + Math.cos(angle) * obstacle.size * 0.5;
                    const spotY = obstacle.y - obstacle.size + Math.sin(angle) * obstacle.size * 0.5;
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, obstacle.size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (obstacle.type === 'log') {
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(obstacle.x - obstacle.size + 2, obstacle.y - 6, obstacle.size * 2, 16);
                
                // Log gradient
                const logGradient = ctx.createLinearGradient(obstacle.x, obstacle.y - 8, obstacle.x, obstacle.y + 8);
                logGradient.addColorStop(0, '#A0522D');
                logGradient.addColorStop(0.5, '#8B4513');
                logGradient.addColorStop(1, '#6B3410');
                
                ctx.fillStyle = logGradient;
                ctx.fillRect(obstacle.x - obstacle.size, obstacle.y - 8, obstacle.size * 2, 16);
                
                // Log outline
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x - obstacle.size, obstacle.y - 8, obstacle.size * 2, 16);
                
                // Wood grain lines
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const y = obstacle.y - 4 + i * 4;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x - obstacle.size, y);
                    ctx.lineTo(obstacle.x + obstacle.size, y);
                    ctx.stroke();
                }
                
                // End caps
                ctx.fillStyle = '#D2691E';
                ctx.beginPath();
                ctx.arc(obstacle.x - obstacle.size, obstacle.y, 8, Math.PI / 2, Math.PI * 1.5);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(obstacle.x + obstacle.size, obstacle.y, 8, -Math.PI / 2, Math.PI / 2);
                ctx.fill();
            }
        }
        
        function gameLoop(currentTime) {
            // ALWAYS continue the loop, even if game is over (for smooth transition)
            game.animationId = requestAnimationFrame(gameLoop);
            
            if (gameState !== 'playing') return;
            
            // Calculate delta time for consistent speed across different frame rates
            const deltaTime = currentTime - game.lastFrameTime;
            game.lastFrameTime = currentTime;
            
            // Normalize to 60 FPS (deltaTime in ms, targeting 16.67ms per frame)
            const frameMultiplier = deltaTime / 16.67;
            
            // Clear canvas with gradient sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#B8D8F0');
            skyGradient.addColorStop(0.7, '#87CEEB');
            skyGradient.addColorStop(1, '#E8F4F8');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw snow on ground with shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, canvas.height - 12, canvas.width, 2);
            
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < canvas.width; i += 20) {
                // Add slight variation to snow mounds
                const moundHeight = 10 + Math.sin(i * 0.5) * 2;
                ctx.beginPath();
                ctx.arc(i + 7.5, canvas.height - 5, 8, Math.PI, 0);
                ctx.fill();
            }
            
            // Calculate scroll speed ONLY from snowball size
            const sizeProgress = (game.snowball.size - 3) / (game.snowball.maxSize - 3);
            game.scrollSpeed = game.baseScrollSpeed + (sizeProgress * 16.8); // Speed goes from 8.4 to 25.2
            
            // Apply frame multiplier for consistent speed
            const actualSpeed = game.scrollSpeed * frameMultiplier;
            
            // Add snow trail particle
            if (game.snowball.size > 0) {
                snowTrail.push({
                    x: game.snowball.x,
                    y: game.snowball.y,
                    size: game.snowball.size * 3,
                    life: 1.0
                });
            }
            
            // Update and draw snow trail
            snowTrail = snowTrail.filter(particle => {
                particle.y -= actualSpeed * 0.3; // Trail moves up slower than obstacles
                particle.life -= 0.015;
                
                if (particle.life > 0) {
                    const alpha = particle.life * 0.6;
                    const currentSize = particle.size * (0.5 + particle.life * 0.5);
                    
                    // Draw with gradient for softer look
                    const trailGradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, currentSize
                    );
                    trailGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    trailGradient.addColorStop(0.5, `rgba(240, 248, 255, ${alpha * 0.6})`);
                    trailGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                    
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    return true;
                }
                return false;
            });
            
            // Spawn obstacles
            game.obstacleSpawnTimer += actualSpeed;
            if (game.obstacleSpawnTimer > 100) {
                spawnObstacle();
                game.obstacleSpawnTimer = 0;
            }
            
            // Update and draw obstacles
            game.obstacles = game.obstacles.filter(obstacle => {
                obstacle.y -= actualSpeed;
                
                // Check collision
                if (checkCollision(game.snowball, obstacle)) {
                    game.snowball.size--;
                    collisions++;
                    
                    if (game.snowball.size <= 0) {
                        gameState = 'gameover';
                        score = Math.floor(game.distance);
                        lastRunDistance = score;
                        lastRunCollisions = collisions;
                        
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('snowballHighScore', highScore);
                        }
                        
                        // Auto-save run to Firebase
                        saveRunToFirebase(score, collisions, currentMaxSize).then(runId => {
                            currentRunId = runId;
                        });
                        
                        showScreen('gameover');
                        return false;
                    }
                    return false;
                }
                
                drawObstacle(obstacle);
                return obstacle.y > -100;
            });
            
            // Draw snowball (only if size is positive)
            if (game.snowball.size > 0) {
                drawSnowball(game.snowball.x, game.snowball.y, game.snowball.size);
            }
            
            // Grow snowball faster over time
            if (Math.floor(game.distance) % 200 === 0 && game.distance > 0) {
                if (game.snowball.size < game.snowball.maxSize) {
                    game.snowball.size = Math.min(game.snowball.maxSize, game.snowball.size + 0.1);
                    // Track max size reached
                    if (game.snowball.size > currentMaxSize) {
                        currentMaxSize = game.snowball.size;
                    }
                }
            }
            
            // Update distance with frame-independent speed
            game.distance += actualSpeed;
            score = Math.floor(game.distance);
            
            // Update HUD display
            updateHUD();
        }
        
        // Initialize
        window.addEventListener('resize', () => {
            if (gameState === 'playing') {
                resizeCanvas();
            }
        });
        
        showScreen('menu');
    </script>
</body>
</html>
